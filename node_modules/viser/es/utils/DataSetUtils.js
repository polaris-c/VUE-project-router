import * as _ from 'lodash';
var DataSet = require('@antv/data-set');
function handleToNumber(row, def) {
    var fields = Array.isArray(def.fields) ? def.fields : [def.fields];
    for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
        var item = fields_1[_i];
        row[item] = parseFloat(row[item]);
    }
    return row;
}
function handleMergeFields(row, item) {
    var fields = item.fields;
    if (!Array.isArray(fields) || fields.length === 0) {
        throw new Error("The merge fields of DataPre must be greater than 0.");
    }
    var newItem = [];
    for (var _i = 0, fields_2 = fields; _i < fields_2.length; _i++) {
        var field = fields_2[_i];
        newItem.push(row[field]);
    }
    row[item.as] = newItem;
    return row;
}
function processExchangeColumnToRowOne(data, item) {
    var itemArr = Array.isArray(item.fields) ? item.fields : [item.fields];
    var finalData = [];
    for (var res in data) {
        if (data.hasOwnProperty(res) && itemArr.indexOf(res) >= 0) {
            for (var i = 0; i < data[res].length; i++) {
                if (!finalData[i]) {
                    finalData[i] = {};
                }
                if (data[res][i]) {
                    finalData[i][res] = data[res][i];
                }
            }
        }
    }
    return finalData;
}
function processExchangeColumnToRowTwo(data, item) {
    var itemArr = Array.isArray(item.fields) ? item.fields : [item.fields];
    var finalData = [];
    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
        var res = data_1[_i];
        var key = res[0];
        if (itemArr.indexOf(key) >= 0) {
            for (var i = 1; i < res.length; i++) {
                if (!finalData[i - 1]) {
                    finalData[i - 1] = {};
                }
                if (res[i]) {
                    finalData[i - 1][key] = res[i];
                }
            }
        }
    }
    return finalData;
}
function processExchangeColumnToRowThree(data, item) {
    var itemArr = Array.isArray(item.fields) ? item.fields : [item.fields];
    var finalData = [];
    var i = 0;
    for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
        var res = data_2[_i];
        var key = itemArr[i];
        for (var i_1 = 0; i_1 < res.length; i_1++) {
            if (!finalData[i_1]) {
                finalData[i_1] = {};
            }
            if (res[i_1]) {
                finalData[i_1][key] = res[i_1];
            }
        }
        i++;
    }
    return finalData;
}
function processCommonTransform(dv, item) {
    if (item.type === 'toNumber') {
        dv = dv.transform({
            type: 'map',
            callback: function (row) {
                return handleToNumber(row, item);
            }
        });
    }
    else if (item.type === 'merge') {
        dv = dv.transform({
            type: 'map',
            callback: function (row) {
                return handleMergeFields(row, item);
            }
        });
    }
    else if (item.type === 'geo.centroid' || item.type === 'geo.region') {
    }
    else {
        dv = dv.transform(item);
    }
    return dv;
}
function createSource(data, dataPre) {
    var ds = new DataSet();
    var dv;
    if (!_.get(dataPre, 'connector')) {
        dv = ds.createView().source(data);
    }
    else {
        dv = ds.createView().source(data, dataPre.connector);
    }
    return dv;
}
export var getProcessedData = function (data, dataPre) {
    if (_.isEmpty(dataPre) || _.isEmpty(dataPre.transform)) {
        return createSource(data, dataPre);
    }
    dataPre.transform = Array.isArray(dataPre.transform) ? dataPre.transform : [dataPre.transform];
    var transform = dataPre.transform;
    if (transform && transform.length) {
        var exchangeType = transform[0].exchangeType;
        if (exchangeType === 'type-1') {
            data = processExchangeColumnToRowOne(data, transform[0]);
        }
        else if (exchangeType === 'type-2') {
            data = processExchangeColumnToRowTwo(data, transform[0]);
        }
        else if (exchangeType === 'type-3') {
            data = processExchangeColumnToRowThree(data, transform[0]);
        }
    }
    var dv = createSource(data, dataPre);
    var ds;
    for (var _i = 0, transform_1 = transform; _i < transform_1.length; _i++) {
        var item = transform_1[_i];
        if (item.exchangeType) {
            continue;
        }
        ds = processCommonTransform(dv, item);
    }
    return ds;
};
export var getDataContent = function (data, dataView) {
    if (dataView === void 0) { dataView = 'rows'; }
    if (_.isArray(dataView) && dataView.length >= 2) {
        var type = dataView[0];
        if (_.isFunction(dataView[1])) {
            if (type === 'nodes') {
                return dataView[1](data.getAllNodes());
            }
            else if (type === 'edges') {
                return dataView[1](data.getAllLinks());
            }
        }
    }
    return data[dataView];
};
//# sourceMappingURL=DataSetUtils.js.map